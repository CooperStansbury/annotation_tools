---
title: "Krippendorff’s alpha"
author: "Cooper Stansbury"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  pdf_document:
    highlight: tango
    number_sections: yes
    toc: yes
    keep_md: no
---


```{r to knit, include=FALSE}
knitr::opts_chunk$set(error = TRUE)
```

# Preliminaries

## Software Dependencies

Here are the packages used in this analysis.

```{r imports, message=FALSE, warning=FALSE}
library("irr")
library("boot")
library("knitr")
library("psych")
```

## Note on Confidence Intervals and Contrast Weights

In this document condifence intervals are computed for default $\alpha = 0.05$. Contrasts weights are defaults also, see the Cohen's Kappa sections for ordinal coding details. 


## Loading/Coding Annotations

For `AB.separate` the coding is as follows:
- A = 1
- B = 2
- Blank = 3

For `AB.together` the coding is as follows:
- AB = 1
- Blank = 2

```{r Load Data}
AB.separate <- read.csv("AB_separate.csv")
AB.together <- read.csv("AB_together.csv")

knitr::kable(head(AB.separate),
             caption='Annotations A/B Separate')

knitr::kable(head(AB.together),
             caption='Annotations A/B Together')
```

# Cohen’s Kappas (pairwise)

## Weighted and Unweighted Cohen's for A/B Separately

For each pair of annotators we calculate Cohen's Kappa (weighted and unweighted). Note that the weight matrix used is as follows:

```{r separate kappa weights, echo=FALSE}
t <- cohen.kappa(AB.separate[, c('LIZ', 'KATHLEEN')])
knitr::kable(t$weight,
             caption="Weights Used for Cohen's Kappa")
```


```{r separate Cohen Kappa}
liz.kath <- cohen.kappa(AB.separate[, c('LIZ', 'KATHLEEN')])
knitr::kable(liz.kath$confid, 
             caption="Liz v. Kathleen Cohen's Kappa (weighted and weighted)",
             digits = 4)

liz.kay <- cohen.kappa(AB.separate[, c('LIZ', 'KAYCEE')])
knitr::kable(liz.kay$confid, 
             caption="Liz v. Kaycee Cohen's Kappa (weighted and weighted)",
             digits = 4)

kath.kay <- cohen.kappa(AB.separate[, c('KATHLEEN', 'KAYCEE')])
knitr::kable(kath.kay$confid, 
             caption="Kathleen v. Kaycee Cohen's Kappa (weighted and weighted)",
             digits = 4)
```


## Weighted and Unweighted Cohen's for A/B Together

The weight matrix used is as follows:

```{r together kappa weights, echo=FALSE}
t <- cohen.kappa(AB.together[, c('LIZ', 'KATHLEEN')])
knitr::kable(t$weight,
             caption="Weights Used for Cohen's Kappa")
```


```{r together Cohen Kappa}
liz.kath <- cohen.kappa(AB.together[, c('LIZ', 'KATHLEEN')])
knitr::kable(liz.kath$confid, 
             caption="Liz v. Kathleen Cohen's Kappa (weighted and weighted)",
             digits = 4)


liz.kay <- cohen.kappa(AB.together[, c('LIZ', 'KAYCEE')])
knitr::kable(liz.kay$confid, 
             caption="Liz v. Kaycee Cohen's Kappa (weighted and weighted)",
             digits = 4)

kath.kay <- cohen.kappa(AB.together[, c('KATHLEEN', 'KAYCEE')])
knitr::kable(kath.kay$confid, 
             caption="Kathleen v. Kaycee Cohen's Kappa (weighted and weighted)",
             digits = 4)
```


# Krippendorff’s alpha

This is the `kripp.alpha()` function from: [https://cran.r-project.org/web/packages/irr/irr.pdf](https://cran.r-project.org/web/packages/irr/irr.pdf) run on the data where blanks are explcitly coded (not `NA`). We provide both nominal and ordinal estimates. From the supplementary material of the foillowing publication we find this a note indicating the lack of confidence intervals for this function, as well as small estimation errors due to the lack of `NA` values. It is worth noting that similar behavior is seen in the Python package `krippendorff`.

1. Zapf A, Castell S, Morawietz L, Karch A. Measuring inter-rater reliability for nominal data – which coefficients and confidence intervals are appropriate? BMC Medical Research Methodology. 2016 Aug 5;16(1):93.

_"In R (R Core Team, Vienna, Austria) there is the package irr (version 0.84) from Gamer et al. [2], which calculates Fleiss’ K and Krippendorff’s alpha, but both without confidence intervals. There is a small error in the estimation of the coincidence matrix for Krippendorff’s alpha if there are no missing values. In the upcoming actualized version this error will be corrected (personal communication). An R-program for the calculation of Krippendorffs alpha with the standard bootstrap confidence interval as applied by us was written by Gruszczynski and can be downloaded via GitHub [3]."_

# Krippendorff’s alpha A/B Separate 

```{r separate Krippendorff, message=FALSE, warning=FALSE}
kripp.alpha(t(AB.separate), "nominal")
kripp.alpha(t(AB.separate), "ordinal")
```

## Krippendorff’s alpha A/B Together

Oridinal and nominal weight matrices will be identical in this case.

```{r together Krippendorff, message=FALSE, warning=FALSE}
kripp.alpha(t(AB.together), "nominal")
```



## Booptstrapped Confidence Intervals

We'll rely on this post ( [https://stackoverflow.com/questions/41944703](https://stackoverflow.com/questions/41944703) ) to using bootstrapiing to build confidence intervals, since the "irr" function doesn't return them. Below is the bootstrapped confidence interval for Krippendorff’s alpha:

```{r bootstrapper, message=FALSE, warning=FALSE}
nominal.alpha <- function(d, w){
  #' a function bootstrap nominal coding of
  #' Krippendorff’s alpha
  data <- t(d[w,])
  kripp.alpha(data, 'nominal')$value 
}

oridinal.alpha <- function(d, w) {
  #' a function bootstrap nominal coding of
  #' Krippendorff’s alpha
      data <- t(d[w,])
      kripp.alpha(data, 'ordinal')$value
}
```

### A/B Separate, Coded Nominally

```{r separate nominal, message=FALSE, warning=FALSE}
b <- boot(data = AB.separate, statistic = nominal.alpha, R = 1000)
b
plot(b)
boot.ci(b, type = "perc")
```

### A/B Separate, Coded Ordinally

```{r separate ordinal, message=FALSE, warning=FALSE}
b <- boot(data = AB.separate, statistic = oridinal.alpha, R = 1000)
b
plot(b)
boot.ci(b, type = "perc")
```

### A/B Together, Coded Norminally

```{r together nominal, message=FALSE, warning=FALSE}
b <- boot(data = AAB.together, statistic = nominal.alpha, R = 1000)
bs
plot(b)
boot.ci(b, type = "perc")
```

